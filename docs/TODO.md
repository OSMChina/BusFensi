# TODO

### 实现目标

1. [ ] 新建公交线路。需要的操作为：

    - [ ] 手动选择或者新建一些站点，得到纯站点公交线路
    - [ ] 手动按顺序选择一定的路径，得到公交线路。这里可能需要用到一些绘制的操作，即通过鼠标指定控制点等方式灵活选择。可能需要处理：双向公交。
    - [ ] 自动按照站点生成公交线路。暂时还没想好怎么实现
    - [ ] 对线路元信息的修改，包括名字，运营单位等等

2. [ ] 编辑公交线路。即对于已经存在的公交进行编辑

    - [ ] 对站点进行新增，删除，重新排序
    - [ ] 对路径进行拓展，收缩，删除和重新连接。
    - [ ] 对线路元信息的修改，包括名字，运营单位等等

3. [ ] 删除公交线路
    
    - [ ] 直接删除即可，后续可能会考虑拼接线路的需求

以上对于单条线路而言的。

同时，我们还需要方便地检索线路信息。目前的大纲还算还行，可以保留。

在以上的本职工作完成了之后，我们还得保证这个编辑器理论上拥有可以不离开编辑器就能进行完备的 OSM 编辑功能。这里我们可以把现有的功能作为一个“模式”保留，虽然很难用很抽象，但是起码功能是完备的，毕竟 Happy Path 可能可以 cover 80% 以上的需求，但是剩下的如果用到要去别的编辑器倒来倒去那就很难绷了<s>我估计会被喷死</s>

初步的构思是新增“编辑模式”的抽象，把现有的逻辑全部干掉变成 fallback 的一个模式。再在新的模式上面写新的好的功能。希望可以彻底摆脱半成品的尴尬地位，至少可以达到生产力的需求——至少也要达到 JOSM 的水平，吧。

### 技术路线

目前的技术实现我不是很满意，所以我会列出很多需要改进的地方。

经过了一番思考我决定吧原来的一些写法推翻重写，所以原先的技术实现如果在这里没有提及，一般来说就是被“优化”掉了。这里可以看作是一个相对完整的技术路线

#### 视图的抽象

这次会将 Outline 和 Property 规范为“视图”，就是一组自适应长度的规范的元素，功能一定，但是理论上可以在任何地方打开。这里可以方便为右键菜单做同一个抽象形式。

考虑到 React 的 Functianal Component, 只需要规定他们的 props 相同 Type 即可。

- [X] 定义一个 View 规范
- [ ] 将 Outline 和 Property 迁移到 View

##### 右键菜单

右键菜单的本体应该是视图，不过它表现上可以作为一个类似 modal 定位的 component,可以在制定的 px 下面显示出来。调用者给他一个视图作为 child 就行，类似一个工具类吧。可以作为 Map View 的子 util

- [ ] 完成 Right Click Modal

##### Outline 视图

视图当中应该有一个可以用来列出和快速检索当前的所有 metadata 的一个模式，需求：

- [ ] 能够完整得到当前获取的数据，包括 Relation, Way, Node
- [ ] 能够得到我们关心的某一类数据，比如公共交通数据
- [ ] 能够得到我们编辑中的数据，比如 Selected

这里我们可以用 Tabs 来实现。然后在对应的 Click Button （比如 Select ）里面去做。

##### Property 视图

- [ ] 显示当前的 Active 元素。Select 元素可以有多个， Active 属于 Select 且唯一。
- [ ] 最好根据类型做判断。已知类型专门显示，最后来个 fallback 纯手工视图。

#### 重构 Zustand 状态管理

- [X] 首先修复 persist state
- [X] 其次，需要拆分 state 了，完全不同的状态需要不同的 slice, 比如 zoom 和 lat lon 可以用 URL store 中间件，而编辑数据需要存在 zundo 中间件。最后在这些 middleware 暴露的接口上面组成一个完整的全局 store 以供使用。

#### 编辑模式的抽象

编辑模式是新引入的一个抽象，属于地图视图，是地图视图的子模式。

模式需要展示数据和编辑数据，数据的展示拥有一组图层（Layer）来显示组件。图层的 JSX 最外层就是一个 PIXI Container, 在 Container 里面根据数据状态绘制各种图像。

对于编辑功能需要一个 Controller, 接受用户的输入，对数据进行操作。由于数据是 Zustand 提供的本地全局状态，因此可以自动和数据展示解耦。

Controller 的实现会比较复杂，所以会给 Controller 一个状态机（stateMachine）来做抽象，归纳用户行为在对应状态下对数据的影响，可以理解成状态机状态转换的输出。

- [X] 定义 Mode Component，使用类似 Tabs 的切换方式
- [X] 将现有代码装进 Mode Component
- [X] 定义 Controller(StateMachine), 接受各种事件，并且执行行为

##### State Machine 实现

现在有 State Machine 的实现，就是不够模块化。虽然不需要搞出行为树这种高级抽象（虽然已本质上没啥差别，主要体现在外围 function 上面），搞点 substate 的抽象还是可以的，这样就可以写类似“按下按钮之后画一个点”这样的抽象。

因为需要模块化，就需要在运行时 new 一些 instance 出来，这样就不会出现不同的 substate 打架的可能性（如果后续拓展的话）。现有的代码都需要一次彻底的重构。

以及，将状态机操作数据看作一种输出，应该也算能够理解的行为，毕竟至少数据还是单向流动的。所以暂时不对这个部分开到，毕竟可以将 zustand 提供的接口视为 edit system， data model 和 view model 的复合，至少在目前还没有局限，后续根据 zustand 的灵活性也能定制拓展。

- [X] 新建一个 State 的 Class, 规范化 State 的实例化和连接，以及状态转移函数。比如 new 之后 appendTransform
- [X] 重构 State Machine，取消 retain, 取消对每个事件的接口，统一抽象。允许 State Machine 之间相互拼接， 使用 appendNext
- [X] 将 Controller 接入 State Machine

#### 新建公交相关业务逻辑编写

现在有了新的抽象，就可以对这个抽象去写出新业务了。

##### 新建空公交线路

按下新建公交按钮，新建空线路，进入公交编辑模式。

这里就新建一个 Relation，并且需要一个编辑 metadata 的引导：使用 property view 。那么这个 property view 的实现暂时放着，我们后续根据需求重新调整抽象。

总之，名字什么的还是需要提示的，但是也支持高级的关系编辑直接加 tags

- [ ] 在 Map View 当中添加切换 Mode 的一列按钮。可以放在左上角。

##### 新建和添加站点

这个应该算一个子编辑模式？反正是由 State Machine 控制的，属于 Mode 抽象内部的私事，耦合就耦合吧。

在这里可以做三件事：

- [ ] 按下新建简易站，绘制一个点，自动添加到站点中
- [ ] 按下新建大站（？换个名字吧），绘制一个闭合的多边形，自动添加到站点中。需要定义编辑状态机
- [ ] 选择一个公交站，右键，打开菜单，将其加入关系。

然后还可以在 property view 里面给站点的顺序进行调整。

##### 手动新建线路

这里需要引入新的，复杂的业务了。

具体参考我的手稿，大体就是通过指定控制点，通过简单的最短路算法计算并且规划线路。这个为了编辑实时性得本地计算，暂时写个简单的抽象进去。就算寻路全烂了，大不了每过一个路口打一个控制点。

- [ ] 完成编辑行为的状态机定义
- [ ] 完成寻路等功能的函数实现
- [ ] 接入编辑功能

##### 自动新建线路

研究 OSRM 的 API, 看看他们怎么规划，然后直接无脑丢。

#### 编辑公交线路

需求类似上方，引入一个编辑线路流程

##### 选择线路

这个确实需要。就是说地图上要有一个显示已有线路的样子，然后可以右键线路进入编辑。

然后呢，还有一个 Outline View 应该也可以点进去

##### 局部重绘

在已有线路上确定一个开始点和一个结束点，参考之前的逻辑

##### 全部重开

同前

##### 手动指定关系的路径

这个得和 property 里面搞配合了。我想到的是 blender 的行为，就是把关系编辑器搞个吸管去 select，但是不清楚怎么抽象好。可能会开洞。

暂时不做也行，相信纯手工模式

#### fallback 纯手动

这个我们可以把剩下的功能没做进去的全部打包成一个纯手工模式，嗯，非常好。

#### 一些跨 View 的关系管理

这很重要，比如典中典 select 应该怎么处理。就是说一些需要开洞实现的功能怎么操作。

我怎么做到按下 Property View 中的吸管的时候把 Map View 的状态给切了去 select, 而且能 select 到的是当前显示的实体中可以兼容的部分。这个还需要思考，可能还会推翻现在的草稿设计。

### 代码组织

我个人的代码组织是比较随意的，所以这里吃回旋镖了。一个是文件夹层级过深，另一个是公共功能不够明显。

这次我希望让类似的逻辑都放在一起，同时引入类似“依赖”的概念，也就是说有些文件夹应该独立，不依赖别的文件夹里面的逻辑，这样可以避免意大利面条式的交错。暂时管这个叫 root 逻辑？用 R 来标记好了。utils 可以被 root 模块引用，叫 U 好了

代码现在的组织很乱。我决定重新调整文件结构。暂时订成这个

```
src
├── api        # (R)封装的，与 OSM v0.6 后端请求的函数
├── app        # 最终的 UI，各个部分在这里组成完整程序
├── components # (R)公共的，可复用的 UI 组件，原则上应该作为 VDOM 的叶子
├── views      # 应用的视图组件，如 Map, Property 等。每个字文件夹相互独立
├── store      # (R)用于状态管理的 zustand store
├── utils      # (U)通用的工具函数
├── config     # （待实现）应用的配置文件，包含客户端环境变量与服务端环境变量
├── const      # （待实现）用于定义常量，如 action 类型、路由名等
├── hooks      # （待实现）全应用复用自定义的工具 Hooks
├── locales    # （待实现）国际化的语言文件
└── types      # （待实现）TypeScript 的类型定义文件
```

所以现在需要实现：

- [X] `components`: 分成 `pixi` 和 `common` 两个文件夹好了。暂时让 common 空着。接下来把 pixi 的组件移进去。需要注意的是这里的 pixi component 需要改成一个完整的依赖 props 的渲染，而不是依赖 store hooks。每个组件分别用 index.tsx 导出
- [X] `store`: 按照这个标准来写 <https://github.com/lobehub/lobe-chat/wiki/State-Management-Intro.zh-CN>。暂时分成 `osmmeta` 和 `settings` 两个部分，一个复杂，一个简单。每个子文件夹 `index.ts` 导出一个 zustand 的 hook
- [ ] `views`: 每个二级文件夹代表一个完整的 view。暂定 `outline` `property` `map`，每个分别一个 `index.tsx` 导出即可
- [ ] `app` 组装成整个 APP。里面包含 layout 等逻辑。这里的逻辑很可能会比较乱，比较杂，但是无所谓，乱到一定程度就拆组件。
